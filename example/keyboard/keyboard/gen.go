// Copyright 2015 Hajime Hoshi
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +build ignore

package main

import (
	"github.com/hajimehoshi/ebiten"
	"github.com/hajimehoshi/ebiten/example/common"
	"github.com/hajimehoshi/ebiten/internal"
	"image"
	"image/color"
	"image/draw"
	"image/png"
	"log"
	"os"
	"text/template"
)

var keyboardKeys = [][]string{
	{"Esc", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", " ", " ", " ", "Del"},
	{"Tab", "Q", "W", "E", "R", "T", "Y", "U", "I", "O", "P", " ", " ", "BS"},
	{"Ctrl", "A", "S", "D", "F", "G", "H", "J", "K", "L", " ", " ", "Enter"},
	{"Shift", "Z", "X", "C", "V", "B", "N", "M", ",", ".", " ", " "},
	{" ", "Alt", "Space", " ", " "},
	{},
	{"", "Up", ""},
	{"Left", "Down", "Right"},
}

func drawKey(t *ebiten.Image, name string, x, y, width int) {
	const height = 16
	width--
	c := color.White
	t.DrawLine(x, y+3, x, y+height-3, c)
	t.DrawLine(x+width-1, y+3, x+width-1, y+height-3, c)
	t.DrawLine(x+3, y, x+width-3, y, c)
	t.DrawLine(x+3, y+height-1, x+width-3, y+height-1, c)

	t.DrawLine(x, y+3, x+3, y, c)
	t.DrawLine(x+width-4, y, x+width-1, y+3, c)
	t.DrawLine(x, y+height-4, x+3, y+height-1, c)
	t.DrawLine(x+width-1, y+height-4, x+width-4, y+height-1, c)

	common.ArcadeFont.DrawText(t, name, x+4, y+5, 1, color.White)
}

func outputKeyboardImage() (map[string]image.Rectangle, error) {
	keyMap := map[string]image.Rectangle{}
	img, err := ebiten.NewImage(320, 240, ebiten.FilterNearest)
	if err != nil {
		return nil, err
	}
	x, y := 0, 0
	for j, line := range keyboardKeys {
		x = 0
		const height = 18
		for i, key := range line {
			width := 16
			switch j {
			default:
				switch i {
				case 0:
					width = 16 + 8*(j+2)
				case len(line) - 1:
					width = 16 + 8*(j+2)
				}
			case 4:
				switch i {
				case 0:
					width = 16 + 8*(j+2)
				case 1:
					width = 16 * 2
				case 2:
					width = 16 * 5
				case 3:
					width = 16 * 2
				case 4:
					width = 16 + 8*(j+2)
				}
			case 6, 7:
				width = 16 * 3
			}
			if key != "" {
				drawKey(img, key, x, y, width)
				if key != " " {
					keyMap[key] = image.Rect(x, y, x+width, y+height)
				}
			}
			x += width
		}
		y += height
	}

	palette := color.Palette([]color.Color{
		color.Transparent, color.Opaque,
	})
	palettedImg := image.NewPaletted(img.Bounds(), palette)
	draw.Draw(palettedImg, palettedImg.Bounds(), img, image.ZP, draw.Src)

	f, err := os.Create("images/keyboard/keyboard.png")
	if err != nil {
		return nil, err
	}
	defer f.Close()
	if err := png.Encode(f, palettedImg); err != nil {
		return nil, err
	}
	return keyMap, nil
}

const keyRectTmpl = `{{.License}}

// DO NOT EDIT: This file is auto-generated by genkeys.go.

package keyboard

import (
	"image"
)

var keyboardKeyRects = map[string]image.Rectangle{}

func init() {
{{range $key, $rect := .KeyRectsMap}}	keyboardKeyRects["{{$key}}"] = image.Rect({{$rect.Min.X}}, {{$rect.Min.Y}}, {{$rect.Max.X}}, {{$rect.Max.Y}})
{{end}}}

func KeyRect(name string) (image.Rectangle, bool) {
	r, ok := keyboardKeyRects[name]
	return r, ok
}`

func outputKeyRectsGo(k map[string]image.Rectangle) error {
	license, err := internal.LicenseComment()
	if err != nil {
		return err
	}
	path := "keyboard/keyboard/keyrects.go"

	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	tmpl, err := template.New(path).Parse(keyRectTmpl)
	if err != nil {
		return err
	}
	return tmpl.Execute(f, map[string]interface{}{
		"License":     license,
		"KeyRectsMap": k,
	})
}

func main() {
	m, err := outputKeyboardImage()
	if err != nil {
		log.Fatal(err)
	}
	if err := outputKeyRectsGo(m); err != nil {
		log.Fatal(err)
	}
}
